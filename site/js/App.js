/**
 * Backbone Global TODOS example -- Provides the canonical TODOS web app using the global ES5 bundle
 * generated by backbone-es6 (https://github.com/typhonjs/backbone-es6). This is a rhetorical demo
 * showing how to consume the library in a global JS context. This is absolutely _NOT_ the recommended way to consume
 * backbone-es6, but gives an example for those converting from global usage to JSPM / SystemJS. Please see
 * backbone-es6-localstorage-todos (https://github.com/typhonjs-demos/backbone-es6-localstorage-todos) for the
 * recommended way to work with backbone-es6 and JSPM / SystemJS.
 */
$(function()
{
   /**
    * Creates a global eventbus for various parts of the app to communicate indirectly rather than invoking direct
    * methods. In particular this allows Views to call functions of the main App.
    */
   var eventbus = new Backbone.Events();

   // Models --------------------------------------------------------------------------------------------------------

   /**
    * This is the transient application state. By using a `Backbone.Model` this also makes it an
    * instance of `Backbone.Events` allowing subscription to state changes. An instance of AppState created after
    * definition allows any other subsequent code to access this instance.
    */
   var AppState = Backbone.Model.extend(
   {
      /**
       * Default value for AppState which is set in `Backbone.Model` when initializing an instance of `AppState`.
       */
      defaults: { filter: 'all' }
   });

   /**
    * Create global appState reference shared between router, views and main app.
    */
   var appState = new AppState();

   /**
    * Our basic todos Item model has `content`, `order`, and `done` attributes.
    */
   var Item = Backbone.Model.extend(
   {
      /**
       * Default attributes for the item.
       */
      defaults:
      {
         content: 'empty todo...',
         done: false
      },

      /**
       * Ensure that each item created has `content`.
       */
      initialize: function()
      {
         if (!this.get('content'))
         {
            this.set({ 'content': this.defaults.content });
         }
      },

      /**
       * Toggle the `done` state of this item.
       */
      toggle: function()
      {
         this.save({ done: !this.get('done') });
      }
   });

   // Collections ---------------------------------------------------------------------------------------------------

   /**
    * This module defines a `Backbone.Collection` which stores todos `Items` and provides utility methods to filter,
    * sort and retrieve the next order number used to sort `Items`. An single shared instance of TodoList is created
    * right after definition below. This allows the instance to be used anywhere the collection is necessary.
    * Multiple views may access this instance, but in this demo only `ManageTodosView` displays data from the
    * collection.
    */
   var TodoList = Backbone.Collection.extend(
   {
      /**
       * Reference to this collection's model.
       */
      model: Item,

      localStorage: new Backbone.LocalStorage('backbone:es6:localstorage:TodoList'),

      /**
       * Todos are sorted by their original insertion order.
       *
       * @param {Item} item - item model.
       * @returns {number}
       */
      comparator: function(item)
      {
         return item.get('order');
      },

      /**
       * Filter down the list of all todos items that are finished.
       *
       * @returns {*}
       */
      done: function()
      {
         return this.filter(function(item) { return item.get('done'); });
      },

      /**
       * We keep the todos Items in sequential order, despite being saved by unordered GUID in the database. This
       * generates the next order number for new items.
       *
       * @returns {number}
       */
      nextOrder: function()
      {
         if (!this.length) { return 1; }
         return this.last().get('order') + 1;
      },

      /**
       * Filter down the list to only todos items that are still not finished.
       *
       * @returns {*}
       */
      remaining: function()
      {
         return this.without.apply(this, this.done());
      }
   });

   /**
    * Create global todoList reference shared between views and main app.
    */
   var todoList = new TodoList();

   // Router --------------------------------------------------------------------------------------------------------

   /**
    * Provides a basic `Backbone.Router` to route between app states: `all`, `active` & `completed`. When a user
    * navigates between these different filter type states `Backbone.history.navigate` is invoked in
    * `App->selectFilter` to update the navigation history allowing the user to use the back and forward browser
    * controls to navigate the app. When a filter type is selected it is referenced in the current URL for the web app.
    * If this URL is navigated to and the user is still logged into the app `AppRouter` will set the `AppState`
    * accordingly and `ManageTodosView` will appropriately show the `Items` for the current user given the filter state
    * set below. If a user is not logged in `App` renders the login view and `AppRouter` will replace any route
    * matches with no hash tag.
    *
    * Please note that in the `App constructor` a default catch all no route callback is specified which handles
    * unmatched routes.
    */
   var AppRouter = Backbone.Router.extend(
   {
      /**
       * Creates the routes delegated to the given methods specified.
       */
      routes:
      {
         'all': function() { appState.set({ filter: 'all' }); },
         'active': function() { appState.set({ filter: 'active' }); },
         'completed': function() { appState.set({ filter: 'completed' }); }
      }
   });

   // Views ---------------------------------------------------------------------------------------------------------

   /**
    * The `Backbone.View` for an item which encapsulates the ability to edit the content of the item. With a desktop
    * browser an `Item` can be edited with a double click or double tap when running on a mobile device. In this case
    * additional jQuery events including `doubletap` are loaded via the jQuery finger
    * plugin (http://ngryman.sh/jquery.finger/).
    */
   var ItemView = Backbone.View.extend(
   {
      /**
       * Defines the tag that is created for an `Item`.
       */
      tagName: 'li',

      /**
       * Delegated events for interacting with an `Item`.
       */
      events:
      {
         'click .toggle': 'toggleDone',
         'dblclick label.todo-content': 'edit',
         'doubletap label.todo-content': 'edit',
         'click .todo-destroy': 'clear',
         'keypress .edit': 'updateOnEnter',
         'blur .edit': 'closeEdit'
      },

      /**
       * Cache the template function for a single item.
       */
      template: _.template($('#template-item').html()),

      /**
       * The ItemView listens for changes to its model, re-rendering. Since there's a one-to-one correspondence between
       * an Item and an ItemView. If the model is deleted then the `Backbone.View->remove` method is invoked.
       */
      initialize: function()
      {
         // Binds the `this` context to all methods such that it is accessible via Backbone event callbacks.
         _.bindAll(this, 'clear', 'closeEdit', 'remove', 'render');

         this.listenTo(this.model, 'change', this.render);
         this.listenTo(this.model, 'destroy', this.remove);
      },

      /**
       * Remove the item, destroy the model.
       */
      clear: function()
      {
         this.model.destroy();
      },

      /**
       * Close the `editing` mode, saving changes to the item.
       */
      closeEdit: function()
      {
         this.model.save({ content: this.input.val() });
         this.$el.removeClass('editing');
      },

      /**
       * Switch this view into `editing` mode, displaying the input field.
       */
      edit: function()
      {
         this.$el.addClass('editing');
         this.input.focus();
      },

      /**
       * Re-render the contents of the Item.
       *
       * @returns {ItemView}
       */
      render: function()
      {
         this.$el.html(this.template(this.model.toJSON()));

         /**
          * @type {object} Stores the edit input.
          */
         this.input = this.$('.edit');

         return this;
      },

      /**
       * Toggle the `done` state of the model.
       */
      toggleDone: function()
      {
         this.model.toggle();
      },

      /**
       * If you hit `enter`, we're through editing the item.
       *
       * @param {object}   e - event data
       */
      updateOnEnter: function(e)
      {
         if (e.keyCode === 13) { this.closeEdit(); }
      }
   });

   /**
    * The main view that lets a user manage their todos `Items`. When the various items are rendered they are tracked
    * in the `itemViews` object hash so that they can be cleaned up correctly.
    */
   var ManageTodosView = Backbone.View.extend(
   {
      el: '.content',

      /**
       * Delegated events for creating new items and clearing completed ones.
       */
      events:
      {
         'keypress #new-todo': 'createOnEnter',
         'click #clear-completed': 'clearCompleted',
         'click #toggle-all': 'toggleAllComplete',
         'click .log-out': function() { eventbus.trigger('app:user:logout'); },
         'click ul#filters a': function(e) { eventbus.trigger('app:select:filter', $(e.target).attr('id')); }
      },

      /**
       * The template for the line of statistics at the bottom of the app.
       */
      statsTemplate: _.template($('#template-stats').html()),

      /**
       * At initialization we bind to the relevant events on the `Todos` collection, when items are added or changed.
       * Kick things off by loading any preexisting todos that might be currently stored via Backbone.LocalStorage.
       *
       * @param {object}   options - optional parameters
       */
      initialize: function(options)
      {
         this.itemViews = {};

         // Binds the `this` context to all methods such that it is accessible via Backbone event callbacks.
         _.bindAll(this, 'addOne', 'addAll', 'addSome', 'createOnEnter', 'render', 'toggleAllComplete');

         // Main todos management template.
         this.$el.html(_.template($('#template-manage-todos').html())(options));

         /**
          * @type {object} Stores the input field.
          */
         this.input = this.$('#new-todo');

         /**
          * @type {object} Stores the toggle all checkbox.
          */
         this.allCheckbox = this.$('#toggle-all')[0];

         var self = this;

         // Useful to get rid of the initial displayed spinner gif. This is called only once when the collection
         // initially is reset.
         this.listenToOnce(todoList, 'reset', function() { self.$('#todo-list').html(''); });

         // When `AppState` changes invoke `filter` to redraw this view.
         this.listenTo(appState, 'change', this.filter);

         // When `todoList` is reset / initially populated or if an Item done state changes invoke `filter` to
         // redraw this view.
         this.listenTo(todoList, 'change:done reset', this.filter);

         // Ensure that the statistics are re-rendered when an item is added or removed.
         this.listenTo(todoList, 'update', this.render);
      },

      /**
       * Add all items in the Todos collection at once.
       */
      addAll: function()
      {
         this.clearAll();

         todoList.each(this.addOne);

         this.render();
      },

      /**
       * Add a single item to the list by creating a view for it, and appending its element to the `<ul>`.
       *
       * @param {Item}  item - Item to add.
       */
      addOne: function(item)
      {
         var view = new ItemView({ model: item });

         this.itemViews[item] = view;

         this.$('#todo-list').append(view.render().el);
      },

      /**
       * Only adds some todos, based on a filtering function that is passed into `addSome`.
       *
       * @param {function} filter - A function to filter the Items.
       */
      addSome: function(filter)
      {
         this.clearAll();

         todoList.chain().filter(filter).each(this.addOne);

         this.render();
      },

      /**
       * Iterates through the `itemViews` invoking the `Backbone.View->remove` method for each `ItemView` tracked.
       * The object hash is then cleared.
       */
      clearAll: function()
      {
         this.$('#todo-list').html('');

         _.each(this.itemViews, function(itemView)
         {
            itemView.remove();
         });

         this.itemViews = {};
      },

      /**
       * Clear all done todos items, destroying their models.
       */
      clearCompleted: function()
      {
         var self = this;

         _.each(todoList.done(), function(item)
         {
            // This will trigger the remove method of ItemView.
            item.destroy();

            // Remove the ItemView from the tracking map.
            delete self.itemViews[item];
         });
      },

      /**
       * If you hit return in the main input field, create new Item model. The creation of the item is handled over
       * the eventbus via triggering `app:create:item` which invokes `App->createItem`.
       *
       * @param {object}   e - event data
       */
      createOnEnter: function(e)
      {
         // Only respond to `enter` pressed.
         if (e.keyCode !== 13) { return; }

         // Create new item.
         eventbus.trigger('app:create:item', this.input.val());

         // Clear the input text field.
         this.input.val('');

         // Sets state and updates Backbone.history.navigate.
         eventbus.trigger('app:select:filter', 'all');
      },

      /**
       * Invoked when the TodoList collection is reset and when the app state changes.
       */
      filter: function()
      {
         var filterValue = appState.get('filter');

         switch(filterValue)
         {
            case 'all':
               this.addAll();
               break;

            case 'completed':
               this.addSome(function(item) { return item.get('done'); });
               break;

            default:
               this.addSome(function(item) { return !item.get('done'); });
               break;
         }
      },

      /**
       * Re-rendering the App just means refreshing the statistics -- the rest of the app doesn't change.
       */
      render: function()
      {
         var done = todoList.done().length;
         var remaining = todoList.remaining().length;

         // Render the statistics template
         this.$('#todo-stats').html(this.statsTemplate({ total: todoList.length, done: done, remaining: remaining }));

         // Automatically wires all events specified by `get events()`.
         this.delegateEvents();

         // Sets the checked state of the allCheckbox depending on remaining count.
         this.allCheckbox.checked = !remaining;

         // Update the filter state after the stats template is rendered.
         var filterValue = appState.get('filter');
         $('ul#filters a').removeClass('selected');
         $('ul#filters a#' + filterValue).addClass('selected');
      },

      /**
       * Toggles all todos items to completed / done then saves each item.
       */
      toggleAllComplete: function()
      {
         var done = this.allCheckbox.checked;
         todoList.each(function(item) { item.save({ done: done }); });
      }
   });

// ----------------------------------

   /**
    * Provides the main entry point for the Todos app and major control functionality (the C in MVC). This control
    * functionality is exposed over an eventbus created by `eventbus` defined at the top of this file.
    *
    * While in this simple app there is only one view of the `TodoList` a benefit of separating control functionality
    * and the `TodoList` instance from a specific view is that it could be used across multiple views.
    */
   function App()
   {
      /**
       * Creates a new Item in the todos list.
       *
       * @param {string}   content - The text for the item.
       */
      this.createItem = function(content)
      {
         // Ensure that content is a string. If so then create a new `Item` entry in `todoList`.
         if (typeof content === 'string')
         {
            todoList.create(
            {
               content: content,
               order: todoList.nextOrder(),
               done: false
            });
         }
      };

      /**
       * Sets the app state with the new filter type and updates `Backbone.History`.
       *
       * @param {string}   filter - Filter type to select.
       */
      this.selectFilter = function(filter)
      {
         // When setting a value on a `Backbone.Model` if the value is the same as what is being set a change event will
         // not be fired. In this case we set the new state with the `silent` option which won't fire any events then
         // we manually trigger a change event so that any listeners respond regardless of the original state value.
         appState.set({ filter: filter }, { silent: true });
         appState.trigger('change', appState);

         // Update the history state with the new filter type.
         Backbone.history.navigate(filter);
      };

      /**
       * Creates and shows a new ManageTodosView then fetches the collection.
       *
       * @returns {*}
       */
      this.showTodos = function()
      {
         if (this.currentView) { this.currentView.close(); }

         Backbone.history.navigate(appState.get('filter'), { replace: true });

         this.currentView = new ManageTodosView();

         // Fetch all the todos items from local storage. Any listeners for `todoList` reset events will be invoked.
         todoList.fetch({ reset: true });

         return this.currentView;
      };

      // Wire up the main eventbus to respond to the following events. By passing in `this` in the third field to
      // `on` that sets the context when the callback is invoked.
      eventbus.on('app:create:item', this.createItem, this);
      eventbus.on('app:select:filter', this.selectFilter, this);

      // Initialize the `AppRouter` and set up a catch all handler then invokes `Backbone.history.start` with the root
      // path of the App.
      new AppRouter();

      // Defines a catch all handler for all non-matched routes (anything that isn't `all`, `active` or `completed`). If
      // a user is logged in the catch all navigates to `all` triggering the route and replacing the invalid route in
      // the browser history.
      Backbone.history.handlers.push(
      {
         route: /(.*)/,
         callback: function() { Backbone.history.navigate('all', { trigger: true, replace: true }); }
      });

      // This regex matches the root path, so that it can be set in `Backbone.history.start`
      var root, urlMatch;

      // Construct the root path to the web app which is the path above the domain that may include `index.html` or
      // `indexSrc.html` depending on the runtime. For instance in WebStorm when creating a local server `index.html` is
      // included in the URL. Running on an actual web server often `index.html` is not put into the URL. When running
      // the app from source code transpiled in the browser `indexSrc.html` is always in the URL.
      if (typeof window.location !== 'undefined')
      {
         const windowLocation = window.location.toString();

         if (windowLocation.includes('.html'))
         {
            urlMatch = windowLocation.match(/\/\/[\s\S]*\/([\s\S]*\/)([\s\S]*\.html)/i);
            root = urlMatch && urlMatch.length >= 3 ? '' + urlMatch[1] + urlMatch[2] : undefined;
         }
         else
         {
            urlMatch = windowLocation.match(/\/\/[\s\S]*\/([\s\S]*\/)/i);
            root = urlMatch && urlMatch.length >= 2 ? urlMatch[1] : undefined;
         }
      }

      Backbone.history.start({ root: root });

      // -----

      /**
       * Creates the initial displayed view based given if a user is currently logged into the app.
       *
       * @type {View} Stores the current active view.
       */
      this.currentView = this.showTodos();
   }

   // Initialize and create a new App instance.
   new App();
});